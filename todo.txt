Program name pipex
Turn in files Makefile, *.h, *.c
Makefile NAME, all, clean, fclean, re
Arguments file1 cmd1 cmd2 file2
External functs.
• open, close, read, write,
malloc, free, perror,
strerror, access, dup, dup2,
execve, exit, fork, pipe,
unlink, wait, waitpid
• ft_printf and any equivalent
YOU coded
Libft authorized Yes

Description
This project is about handling pipes.
Your program will be executed as follows:
./pipex file1 cmd1 cmd2 file2

It must take 4 arguments:
• file1 and file2 are file names.
• cmd1 and cmd2 are shell commands with their parameters.

It must behave exactly the same as the shell command below:
$> < file1 cmd1 | cmd2 > file2

III.1 Examples
$> ./pipex infile "ls -l" "wc -l" outfile
Should behave like: < infile ls -l | wc -l > outfile
$> ./pipex infile "grep a1" "wc -w" outfile
Should behave like: < infile grep a1 | wc -w > outfile

III.2 Requirements
Your project must comply with the following rules:
• You have to turn in a Makefile which will compile your source files. It must not
relink.
• You have to handle errors thoroughly. In no way your program should quit unex-
pectedly (segmentation fault, bus error, double free, and so forth).
• Your program mustn’t have memory leaks.
• If you have any doubt, handle the errors like the shell command:
< file1 cmd1 | cmd2 > file2

Bonus part
You will get extra points if you:
• Handle multiple pipes.
This:
$> ./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2
Should behave like:
< file1 cmd1 | cmd2 | cmd3 ... | cmdn > file2
• Support « and » when the first parameter is "here_doc".
This:
$> ./pipex here_doc LIMITER cmd cmd1 file
Should behave like:
cmd << LIMITER | cmd1 >> file

-----

nao ta a dizer nada sobre variaveis globais serem proibidas
preciso de usar o environ da <unistd.h>

->questoes do PATH:
. "/usr/bin/which"
. retorno do comando "which"

-> colocar varias mensagens de erro caso os comandos ou file names
estejam mal escritos e dem erro
tipo "Command "%s" does not exist or is not working\n"
ou "File "%s" does not exist ou has access problems\n"
se possivel, usar logo exit(0) nos errors
(garantir que tenho todos os frees dados ate esse momento)


----
. libft parece compilar direito
. make pipe loop bonus (acho que ta)
. proc all (parece estar)
. (STDIN e STDOUT library)
. (last cmd flags)
. (erros, first cmd, etc)

. valgrind
. norminette
. Makefile
. readme e .vscode?

- ERROS E FREES
----

testing

este erro estava a deixar me irritado c razao, porque nao faz
sentido, a sintaxe tava bem

pipes estavam bem, comando estava bem, nada de pointers
era problema daquela merda do proc
pipe V
comando V
acho que ta feito

->->-> usar este quickfix para resolver o problema do comando mau primeiro
e depois sim resolver isto e usar o pipe etc
else if (all->cmds->next == NULL) {
		ft_printf("next is NULL!!!\n");
	}
no proc, em vez de new = new->next; new = malloc,
fiz new->next = malloc; new = new->next e passou a dar
----
Libft:
-> testar as funções com os novos nomes das auxiliares e verificar q funcionam
bem e sem leaks de memória para não me lixarem futuros projetos
-> usar o file stuff para testar isso talvez
-> criar uma newlib reorganizada, em que o getnext e o print usam as funções da libft

acho que, se incluires uma função errada no ficheiro .h, não faz grande diferença,
apenas fica lá a existir mas nunca é chamada
o mesmo acontece c funções auxiliares c o mesmo nome das funções do libft,
desde que não incluas #include "libft", é uma função apenas exclusiva desse
file e não tem importancia
só não percebi é como compilou tendo em conta que eu uso várias vezes a ff_strlen
modificada mas não a tenho escrita em lado nenhum, apenas declaro sem a ter criado
ora bem:
- compilo uma biblioteca;
- a biblioteca compila as funções que eu incluo dos files .h;
- não existindo conflitos nos headers, a biblioteca compila na mesma;
- pode até existir conflito algures nos files, mas a biblioteca só usa o
que está no header então não deteta nem cria problemas
a diferença se calhar está entre compilar uma biblioteca e um programa? idk
biblio: .c=.o, compile .a
exec: .c=.o, compile exec
----
mandatory:
4 args, file in/out, commands 1/2

1. arg processing
- criar struct;
- guardar char * com nomes dos files;
- fork(), pipe() e execve() do "which" command para nos retornar o PATH;
- esse path vai ser usado no execve dos comandos 1/2
- guardar tudo na struct all;

2. first command
- pipe[0] que comunica com a main function;
- fork, execve do primeiro comando,
    dup() para redirecionar output para pipe, pipe[1] do output;

3. (bonus) multiple commands
- repetir o procedimento do first command n vezes, consoante o numero
    de pipes, criando pipes novos de cada vez e gerindo pipes
    simultaneos

4. last command