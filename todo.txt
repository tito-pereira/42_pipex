Program name pipex
Turn in files Makefile, *.h, *.c
Makefile NAME, all, clean, fclean, re
Arguments file1 cmd1 cmd2 file2
External functs.
• open, close, read, write,
malloc, free, perror,
strerror, access, dup, dup2,
execve, exit, fork, pipe,
unlink, wait, waitpid
• ft_printf and any equivalent
YOU coded
Libft authorized Yes

Description
This project is about handling pipes.
Your program will be executed as follows:
./pipex file1 cmd1 cmd2 file2

It must take 4 arguments:
• file1 and file2 are file names.
• cmd1 and cmd2 are shell commands with their parameters.

It must behave exactly the same as the shell command below:
$> < file1 cmd1 | cmd2 > file2

III.1 Examples
$> ./pipex infile "ls -l" "wc -l" outfile
Should behave like: < infile ls -l | wc -l > outfile
$> ./pipex infile "grep a1" "wc -w" outfile
Should behave like: < infile grep a1 | wc -w > outfile

III.2 Requirements
Your project must comply with the following rules:
• You have to turn in a Makefile which will compile your source files. It must not
relink.
• You have to handle errors thoroughly. In no way your program should quit unex-
pectedly (segmentation fault, bus error, double free, and so forth).
• Your program mustn’t have memory leaks.
• If you have any doubt, handle the errors like the shell command:
< file1 cmd1 | cmd2 > file2

Bonus part
You will get extra points if you:
• Handle multiple pipes.
This:
$> ./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2
Should behave like:
< file1 cmd1 | cmd2 | cmd3 ... | cmdn > file2
• Support « and » when the first parameter is "here_doc".
This:
$> ./pipex here_doc LIMITER cmd cmd1 file
Should behave like:
cmd << LIMITER | cmd1 >> file

-----

minha libft vai ter certas funcoes auxiliares com o mesmo nome
->mudar o nome das auxiliares dentro do printf e getnext

-----
recebo 4 args
1 - file1 ou myinput+LIMITER
2 - comando 1
3 - comando 2
4 - file2 ou output

pipe(fd0, fd1)
wait(NULL)
    fork
        close (fd0)
        open (file1)
        read all1
        execcmd1 (all1)
        write (fd1)
        close (fd0)
read (fd0) all1
close fd1, close fd0
if (pid1 != 0)
    pipe (fd2, fd3)
    wait(NULL)

o segundo fork dentro do primeiro
pipe dentro do primeiro fork

porque é que este projeto está a parecer super pequeno?
Falta algo aqui tho

execve, que tipo de valores retorna?
para começar a fazer já o código em si

->acabar videos
->aprender a usar a execve e dups

pipe(fd1);
fork();
    if (pid1 == 0)
    close(fd1[0]);
    fork();
        if (pid2 == 0)
        dup1 -> write(pipe1);
        execve(ac[2]);
    else
    wait(NULL);
    close(fd1[1]);
else
wait(NULL);
close(fd1[1]);
pipe(fd2);
close(fd2[0]);
read(fd1[0], fd2[1]);
close(fd1[0]);
close(fd2[0]);
fork();
    if (pid3 == 0)
    close(fd2[1]);
    close(fd3[0]);
    read(fd2[0], fd3[1]);
    fork()
        if (pid4 == 0)
        dup -> fd3[1];
        execve(av[3], arr, environ);
    close(fd2[0]);
    close(fd3[1]);

posso ler para um char * ou tem que ser para um file?

ls -l
argumentos?
sera q o input tambem leva redirection?
out = open(av[4], O_CREATE, O_EXC ou O_APPEND);
dup(out(fd do ficheiro output));
execve(av[3]);

um file que possui nomes de outros files, directory
comandos de shell sao executados em files sim, mas em files de directory
se tentar fazer ls num file .c, apenas me retorna o path que escrevi
-----
exec() abre outro processo novo de terminal, corre, e se
resultar tudo bem fecha o processo que o iniciou
-----
correr comandos(executaveis) na shell e o mesmo que
fazer forks e passar argumentos para execs (command-line)
o directory atual deve fazer parte das enviroments, um comando
cd .. altera o environment DIRECTORY por exemplo, tipo flags de status
o terminal e sempre o mesmo e corre sempre a partir do inicio, temos sempre que
percorrer um PATH ate ao local dos ficheiros que queremos executar
(files .c que contem os comandos de shell)
file 1 (.c com int main() a executar, shell command)
file 2, 3, 4, argumentos a passar a esse int main()
(usa file descriptors para open, read, close, e realizar todos os
comandos de shell)
os proprios int main() precisam de aceder as env var para as alterar, entao
passamos isso como args tambem quando necessario
(por isso que precisamos de passar isso no execve, porque vamos correr
shell commands q usam envp como parametro)
shell simula o CPU:
file 1 = morada de buscar instrucoes
file 2 = morada de buscar data
file 3 = morada de largar data processada

nao ta a dizer nada sobre variaveis globais serem proibidas
preciso de usar o environ da <unistd.h>

->preciso de retornar o PATH talvez, ou escrever eu proprio, ou com
um define

-> depois do primeiro comando, fazer um codigo geral para
"more commands", seja para um so pipe (mandatory) ou varios
pipes (bonus)

-> colocar varias mensagens de erro caso os comandos ou file names
estejam mal escritos e dem erro
tipo "Command "%s" does not exist or is not working\n"
ou "File "%s" does not exist ou has access problems\n"
se possivel, usar logo exit(0) nos errors
(garantir que tenho todos os frees dados ate esse momento)

-> estudar as redirections, tanto de input como output,
e depois tou pronto para comecar com o pipex, e parece me ser rapido
ate