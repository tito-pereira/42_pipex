Program name pipex
Turn in files Makefile, *.h, *.c
Makefile NAME, all, clean, fclean, re
Arguments file1 cmd1 cmd2 file2
External functs.
• open, close, read, write,
malloc, free, perror,
strerror, access, dup, dup2,
execve, exit, fork, pipe,
unlink, wait, waitpid
• ft_printf and any equivalent
YOU coded
Libft authorized Yes

Description
This project is about handling pipes.
Your program will be executed as follows:
./pipex file1 cmd1 cmd2 file2

It must take 4 arguments:
• file1 and file2 are file names.
• cmd1 and cmd2 are shell commands with their parameters.

It must behave exactly the same as the shell command below:
$> < file1 cmd1 | cmd2 > file2

III.1 Examples
$> ./pipex infile "ls -l" "wc -l" outfile
Should behave like: < infile ls -l | wc -l > outfile
$> ./pipex infile "grep a1" "wc -w" outfile
Should behave like: < infile grep a1 | wc -w > outfile

III.2 Requirements
Your project must comply with the following rules:
• You have to turn in a Makefile which will compile your source files. It must not
relink.
• You have to handle errors thoroughly. In no way your program should quit unex-
pectedly (segmentation fault, bus error, double free, and so forth).
• Your program mustn’t have memory leaks.
• If you have any doubt, handle the errors like the shell command:
< file1 cmd1 | cmd2 > file2

Bonus part
You will get extra points if you:
• Handle multiple pipes.
This:
$> ./pipex file1 cmd1 cmd2 cmd3 ... cmdn file2
Should behave like:
< file1 cmd1 | cmd2 | cmd3 ... | cmdn > file2
• Support « and » when the first parameter is "here_doc".
This:
$> ./pipex here_doc LIMITER cmd cmd1 file
Should behave like:
cmd << LIMITER | cmd1 >> file

-----

minha libft vai ter certas funcoes auxiliares com o mesmo nome
->mudar o nome das auxiliares dentro do printf e getnext

-----
recebo 4 args
1 - file1 ou myinput+LIMITER
2 - comando 1
3 - comando 2
4 - file2 ou output

pipe(fd0, fd1)
wait(NULL)
    fork
        close (fd0)
        open (file1)
        read all1
        execcmd1 (all1)
        write (fd1)
        close (fd0)
read (fd0) all1
close fd1, close fd0
if (pid1 != 0)
    pipe (fd2, fd3)
    wait(NULL)

o segundo fork dentro do primeiro
pipe dentro do primeiro fork

vou ter que realizar comandos de shell e fazer pipe,
isto e, aplicar o segundo comando ao output do primeiro
e depois mandar o output desse para onde a redirection mandar
e se nao existir o file de output final, cria-se

para ja ainda estou a ler
mas ainda nao percebi para que vou usar fork, pipes, dup, etc
no minishell ainda percebo, aqui nao

->acabar videos
->aprender a usar a execve